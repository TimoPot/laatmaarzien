import {
  computed,
  DestroyRef,
  effect,
  inject,
  Injectable,
  signal,
} from "@angular/core";
import { takeUntilDestroyed } from "@angular/core/rxjs-interop";
import { CardsData } from "./cards-data";
import { of, Subject } from "rxjs";
import { Card } from "../interfaces/card";

export interface CategoriesState {
  selectedCategory?: number; // id of currently selected category
  allCategories: Card[]; // list of all categories
  mainCategories: Card[]; // list of main categories
  mainCategoriesIDs: number[]; // list of main categories IDs
  subCategoriesOfSelected?: Card[];
  subCategoriesIDsOfSelected?: number[];
  navigationIdsStack?: number[][]; // stack of category IDs for navigation
}

@Injectable({
  providedIn: "root",
})
export class CategoriesService {
  private destroyRef = inject(DestroyRef);

  // SELECTORS
  allCategories = computed(() => this.state().allCategories);
  mainCategories = computed(() => this.state().mainCategories);
  mainCategoriesIDs = computed(() => this.state().mainCategoriesIDs);
  subCategoriesOfSelected = computed(
    () => this.state().subCategoriesOfSelected || []
  );
  selectedCategory = computed(() =>
    this.state().allCategories.find(
      (c) => c.id === this.state().selectedCategory
    )
  );

  // STATE
  private state = signal<CategoriesState>({
    selectedCategory: 0,
    allCategories: [],
    mainCategories: [],
    mainCategoriesIDs: [],
    subCategoriesOfSelected: [],
    subCategoriesIDsOfSelected: [],
    navigationIdsStack: [],
  });

  // SOURCES
  private categories$ = of(CardsData);
  select$ = new Subject<number>();
  selectPreviousCategory$ = new Subject<number>();
  selectNextCateogory$ = new Subject<number>();
  selectParentCategory$ = new Subject<number>();

  constructor() {
    // REDUCERS

    // Load categories
    this.categories$
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((categories) => {
        this.state.update((state) => ({
          ...state,
          selectedCategory: 0, // is the top level categoryies
          allCategories: categories,
          mainCategories: categories.filter((c) => c.isMainCategory),
          mainCategoriesIDs: categories
            .filter((c) => c.isMainCategory)
            .map((c) => c.id),
          subCategoriesOfSelected: categories.filter((c) => c.isMainCategory),
          subCategoriesIDsOfSelected: categories
            .filter((c) => c.isMainCategory)
            .map((c) => c.id),
        }));
      });

    // Update selected category
    this.select$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((id) => {
      const allCategories = this.state().allCategories;
      let subCategoriesIdsOfSelected: number[] = [];
      let stack: number[][] = [];

      console.log("Selected category:", id);
      // update navigation stack if id > 0
      if (id === 0) {
        subCategoriesIdsOfSelected = this.state().mainCategoriesIDs;
      }
      if (id > 0) {
        stack = [
          ...(this.state().navigationIdsStack ?? []),
          this.state().subCategoriesIDsOfSelected || [],
        ];
        // get subcategories id's of selected category
        subCategoriesIdsOfSelected =
          allCategories.filter((c) => c.id === id)[0]?.children || [];
      }

      // get subcategories of above selected subcategories id's
      const subCategoriesOfSelected = allCategories.filter((c) =>
        subCategoriesIdsOfSelected?.includes(c.id)
      );

      // update state
      this.state.update((state) => ({
        ...state,
        selectedCategory: id,
        subCategoriesOfSelected: subCategoriesOfSelected,
        subCategoriesIDsOfSelected: subCategoriesIdsOfSelected,
        navigationIdsStack: stack,
      }));
    });

    effect(() => {
      console.log("Categories state changed:", this.state());
    });
  }
}
